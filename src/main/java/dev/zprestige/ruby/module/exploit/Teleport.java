package dev.zprestige.ruby.module.exploit;

import dev.zprestige.ruby.module.Module;
import dev.zprestige.ruby.setting.impl.BooleanSetting;
import dev.zprestige.ruby.setting.impl.FloatSetting;
import dev.zprestige.ruby.setting.impl.IntegerSetting;
import dev.zprestige.ruby.setting.impl.KeySetting;
import dev.zprestige.ruby.util.EntityUtil;
import dev.zprestige.ruby.util.MessageUtil;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.CPacketPlayer;
import org.lwjgl.input.Keyboard;

import java.util.function.Predicate;

/**
 * -Invented by TuxISCool
 * -Worked out by zPrestige_
 */

public class Teleport extends Module {
    public FloatSetting force = createSetting("Force", 1.0f, 0.1f, 10.0f);
    public IntegerSetting attempts = createSetting("Attempts", 10, 1, 20);
    public IntegerSetting distance = createSetting("Distance", 5, 1, 50);
    public KeySetting enemyTpKey = createSetting("Enemy Tp Key", Keyboard.KEY_NONE);
    public KeySetting oneBlockKey = createSetting("One Block Key", Keyboard.KEY_NONE);
    public BooleanSetting hold = createSetting("Hold", false);
    public BooleanSetting airGlide = createSetting("Air Glide", false);
    public FloatSetting verticalGlideSpeed = createSetting("Vertical Glide Speed", 1.0f, 0.1f, 100.0f, (Predicate<Float>) v-> airGlide.getValue());
    public boolean executed;

    @Override
    public void onTick() {
        if (enemyTpKey.getKey() != Keyboard.KEY_NONE){
            if (Keyboard.isKeyDown(enemyTpKey.getKey())) {
                EntityPlayer entityPlayer = EntityUtil.getTarget(200.0f);
                if (entityPlayer == null) {
                    MessageUtil.sendMessage("No target found unable to teleport.");
                    return;
                }
                for (int i = 0; i < attempts.getValue(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValue() / 10.0f), mc.player.posZ, false));
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(entityPlayer.posX, mc.player.posY, entityPlayer.posZ, true));
                }
                return;
            }
        }
        if (airGlide.getValue()) {
            mc.player.motionY = -0.01;
            double currY = mc.player.posY;
            if (mc.gameSettings.keyBindJump.isKeyDown()) {
                for (int i = 0; i < attempts.getValue(); ++i) {
                    mc.player.setPosition(mc.player.posX, currY + verticalGlideSpeed.getValue() / 100f, mc.player.posZ);
                }
            }
            if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                for (int i = 0; i < attempts.getValue(); ++i) {
                    mc.player.setPosition(mc.player.posX, currY - (verticalGlideSpeed.getValue() / 100f), mc.player.posZ);
                }
            }
        }
        if (oneBlockKey.getKey() != Keyboard.KEY_NONE){
            if (Keyboard.isKeyDown(oneBlockKey.getKey())){
                for (int i = 0; i < attempts.getValue(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValue() / 10.0f), mc.player.posZ, false));
                    switch (mc.player.getHorizontalFacing()) {
                        case NORTH:
                            sendPacket(0, 0, -1, true);
                            break;
                        case EAST:
                            sendPacket(1, 0, 0, true);
                            break;
                        case SOUTH:
                            sendPacket(0, 0, 1, true);
                            break;
                        case WEST:
                            sendPacket(-1, 0, 0, true);
                            break;
                    }
                }
            }
        }
        if (mc.gameSettings.keyBindAttack.isKeyDown()) {
            if (!executed || hold.getValue()) {
                for (int i = 0; i < attempts.getValue(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValue() / 10.0f), mc.player.posZ, false));
                    switch (mc.player.getHorizontalFacing()) {
                        case NORTH:
                            sendPacket(0, 0, -distance.getValue(), true);
                            break;
                        case EAST:
                            sendPacket(distance.getValue(), 0, 0, true);
                            break;
                        case SOUTH:
                            sendPacket(0, 0, distance.getValue(), true);
                            break;
                        case WEST:
                            sendPacket(-distance.getValue(), 0, 0, true);
                            break;
                    }
                    executed = true;
                }
            }
        } else {
            executed = false;
        }
    }

    public void sendPacket(double x, double y, double z, boolean onGroundIn) {
        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + x, mc.player.posY + y, mc.player.posZ + z, onGroundIn));
    }
}