package dev.zprestige.ruby.module.exploit;

import dev.zprestige.ruby.Ruby;
import dev.zprestige.ruby.module.Module;
import dev.zprestige.ruby.settings.impl.Key;
import dev.zprestige.ruby.settings.impl.Slider;
import dev.zprestige.ruby.settings.impl.Switch;
import dev.zprestige.ruby.util.EntityUtil;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.CPacketPlayer;
import org.lwjgl.input.Keyboard;

/**
 * -Invented by TuxISCool
 * -Worked out by zPrestige_
 */

public class Teleport extends Module {
    public final Slider force = Menu.Slider("Force", 0.1f, 10.0f);
    public final Slider attempts = Menu.Slider("Attempts", 1, 20);
    public final Slider distance = Menu.Slider("Distance", 1, 50);
    public final Key enemyTpKey = Menu.Key("Enemy Tp Key", Keyboard.KEY_NONE);
    public final Key oneBlockKey = Menu.Key("One Block Key", Keyboard.KEY_NONE);
    public final Switch hold = Menu.Switch("Hold");
    public final Switch airGlide = Menu.Switch("Air Glide");
    public final Slider verticalGlideSpeed = Menu.Slider("Vertical Glide Speed", 0.1f, 100.0f);
    public boolean executed;

    @Override
    public void onTick() {
        if (enemyTpKey.GetKey() != Keyboard.KEY_NONE) {
            if (Keyboard.isKeyDown(enemyTpKey.GetKey())) {
                EntityPlayer entityPlayer = EntityUtil.getTarget(200.0f);
                if (entityPlayer == null) {
                    Ruby.chatManager.sendMessage("No target found unable to teleport.");
                    return;
                }
                for (int i = 0; i < attempts.GetSlider(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.GetSlider() / 10.0f), mc.player.posZ, false));
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(entityPlayer.posX, mc.player.posY, entityPlayer.posZ, true));
                }
                return;
            }
        }
        if (airGlide.GetSwitch()) {
            mc.player.motionY = -0.01;
            double currY = mc.player.posY;
            if (mc.gameSettings.keyBindJump.isKeyDown()) {
                for (int i = 0; i < attempts.GetSlider(); ++i) {
                    mc.player.setPosition(mc.player.posX, currY + verticalGlideSpeed.GetSlider() / 100f, mc.player.posZ);
                }
            }
            if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                for (int i = 0; i < attempts.GetSlider(); ++i) {
                    mc.player.setPosition(mc.player.posX, currY - (verticalGlideSpeed.GetSlider() / 100f), mc.player.posZ);
                }
            }
        }
        if (oneBlockKey.GetKey() != Keyboard.KEY_NONE) {
            if (Keyboard.isKeyDown(oneBlockKey.GetKey())) {
                for (int i = 0; i < attempts.GetSlider(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.GetSlider() / 10.0f), mc.player.posZ, false));
                    switch (mc.player.getHorizontalFacing()) {
                        case NORTH:
                            sendPacket(0, 0, -1, true);
                            break;
                        case EAST:
                            sendPacket(1, 0, 0, true);
                            break;
                        case SOUTH:
                            sendPacket(0, 0, 1, true);
                            break;
                        case WEST:
                            sendPacket(-1, 0, 0, true);
                            break;
                    }
                }
            }
        }
        if (mc.gameSettings.keyBindAttack.isKeyDown()) {
            if (!executed || hold.GetSwitch()) {
                for (int i = 0; i < attempts.GetSlider(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.GetSlider() / 10.0f), mc.player.posZ, false));
                    switch (mc.player.getHorizontalFacing()) {
                        case NORTH:
                            sendPacket(0, 0, -distance.GetSlider(), true);
                            break;
                        case EAST:
                            sendPacket(distance.GetSlider(), 0, 0, true);
                            break;
                        case SOUTH:
                            sendPacket(0, 0, distance.GetSlider(), true);
                            break;
                        case WEST:
                            sendPacket(-distance.GetSlider(), 0, 0, true);
                            break;
                    }
                    executed = true;
                }
            }
        } else {
            executed = false;
        }
    }

    public void sendPacket(double x, double y, double z, boolean onGroundIn) {
        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + x, mc.player.posY + y, mc.player.posZ + z, onGroundIn));
    }
}