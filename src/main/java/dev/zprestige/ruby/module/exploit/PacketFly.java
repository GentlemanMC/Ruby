package dev.zprestige.ruby.module.exploit;

import dev.zprestige.ruby.eventbus.annotation.RegisterListener;
import dev.zprestige.ruby.events.MoveEvent;
import dev.zprestige.ruby.events.PacketEvent;
import dev.zprestige.ruby.module.Module;
import dev.zprestige.ruby.setting.impl.BooleanSetting;
import dev.zprestige.ruby.setting.impl.FloatSetting;
import dev.zprestige.ruby.setting.impl.IntegerSetting;
import dev.zprestige.ruby.setting.impl.ModeSetting;
import dev.zprestige.ruby.util.EntityUtil;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;

import java.util.Arrays;
import java.util.Objects;
import java.util.function.Predicate;

public class PacketFly extends Module {
    public final ComboBox type = Menu.Switch("Type", "Packet", Arrays.asList("Packet", "Teleport", "Vanilla", "Factor"));
    public final Slider horizontalFactor = Menu.Switch("Horizontal Factor", 1.0f, 0.1f, 10.0f);
    public final Slider upFactor = Menu.Switch("Up Factor", 1.0f, 0.1f, 10.0f);
    public final Slider downFactor = Menu.Switch("Down Factor", 1.0f, 0.1f, 10.0f);
    public final Switch setBack = Menu.Switch("Set Back", false);
    public final Slider setBackValue = Menu.Switch("Set Back Value", 5, 0, 10, (Predicate<Integer>) v -> setBack.getValue());
    public final Switch noVelocity = Menu.Switch("No Velocity", false);
    public final Switch looped = Menu.Switch("Looped", false);
    public final Slider loops = Menu.Switch("Loops", 1, 1, 10, (Predicate<Integer>) v -> looped.getValue());
    public final Switch confirmTeleport = Menu.Switch("Confirm Teleport", false);
    public final Switch confirmExtraTeleport = Menu.Switch("Confirm Extra Teleport", false, v -> confirmTeleport.getValue());
    public final Switch removeFlags = Menu.Switch("Remove Flags", false);
    public final Switch setRotations = Menu.Switch("Set Rotations", false);
    public final ComboBox setPosMode = Menu.Switch("Set Pos Mode", "None", Arrays.asList("None", "Push", "Pull"));
    public final Switch noClip = Menu.Switch("No Clip", false);
    public final Switch noCollisions = Menu.Switch("No Collisions", false);
    public final Switch spoofOnGround = Menu.Switch("Spoof On Ground", false);
    public final Switch useTimer = Menu.Switch("Use Timer", false);
    public final Slider timerValue = Menu.Switch("Timer Value", 1.0f, 0.1f, 2.0f);
    public int setBackTicks;

    @Override
    public void onTick() {
        mc.player.onGround = spoofOnGround.getValue();
        mc.player.noClip = !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(0.0, 0.0, 0.0)).isEmpty() && noClip.getValue();
        mc.player.collidedHorizontally = !noCollisions.getValue();
        mc.player.collidedVertically = !noCollisions.getValue();
        if (noVelocity.getValue())
            mc.player.setVelocity(0, 0, 0);
        if (setBack.getValue() && setBackTicks >= setBackValue.getValue()) {
            setBackTicks = 0;
            return;
        }
        mc.timer.tickLength = 50.0f / (useTimer.getValue() ? timerValue.getValue() : 1.0f);
        if (mc.gameSettings.keyBindJump.isKeyDown()) {
            if (looped.getValue()) {
                for (int i = 0; i < (looped.getValue() ? loops.getValue() : 1); i++) {
                    switch (type.getValue()) {
                        case "Factor":
                            mc.player.motionY = upFactor.getValue() / 100f;
                        case "Packet":
                            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + upFactor.getValue() / 100f, mc.player.posZ, false));
                            break;
                        case "Teleport":
                            mc.player.setPosition(mc.player.posX, mc.player.posY + upFactor.getValue() / 100f, mc.player.posZ);
                            break;
                        case "Vanilla":
                            mc.player.motionY = upFactor.getValue() / 100f;
                    }
                }
            }
        } else if (type.getValue().equals("Factor")) {
            mc.player.motionY = -downFactor.getValue() / 100f;
        }
        if (mc.gameSettings.keyBindSneak.isKeyDown()) {
            if (looped.getValue()) {
                for (int i = 0; i < (looped.getValue() ? loops.getValue() : 1); i++) {
                    switch (type.getValue()) {
                        case "Factor":
                            break;
                        case "Packet":
                            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - downFactor.getValue() / 100f, mc.player.posZ, false));
                            break;
                        case "Teleport":
                            mc.player.setPosition(mc.player.posX, mc.player.posY - downFactor.getValue() / 100f, mc.player.posZ);
                            break;
                        case "Vanilla":
                            mc.player.motionY = -downFactor.getValue() / 100f;
                    }
                }
            }
        }
        if (mc.gameSettings.keyBindForward.isKeyDown() || mc.gameSettings.keyBindLeft.isKeyDown() || mc.gameSettings.keyBindBack.isKeyDown() || mc.gameSettings.keyBindRight.isKeyDown()) {
            double[] motion = EntityUtil.getSpeed(horizontalFactor.getValue() / 100f);
            for (int i = 0; i < (looped.getValue() ? loops.getValue() : 1); i++) {
                switch (type.getValue()) {
                    case "Factor":
                        break;
                    case "Packet":
                        Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayer.Position(mc.player.posX + motion[0], mc.player.posY, mc.player.posZ + motion[1], false));
                        break;
                    case "Teleport":
                        mc.player.setPosition(mc.player.posX + motion[0], mc.player.posY, mc.player.posZ + motion[1]);
                        break;
                    case "Vanilla":
                        mc.player.motionX = motion[0];
                        mc.player.motionZ = motion[1];
                }
            }
        }
        if (setBack.getValue() && setBackTicks < setBackValue.getValue())
            setBackTicks++;
    }


    @RegisterListener
    public void onMove(MoveEvent event) {
        if (nullCheck() || !isEnabled())
            return;
        double[] motion = EntityUtil.getSpeed(horizontalFactor.getValue() / 100f);
        if (type.getValue().equals("Factor")) {
            event.motionX = motion[0];
            event.motionZ = motion[1];
        } else
            event.setCancelled(true);
    }

    @RegisterListener
    public void onPacketReceive(PacketEvent.PacketReceiveEvent event) {
        if (nullCheck() || !isEnabled() || !(event.getPacket() instanceof SPacketPlayerPosLook))
            return;
        if (confirmTeleport.getValue()) {
            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketConfirmTeleport(((SPacketPlayerPosLook) event.getPacket()).getTeleportId()));
            if (confirmExtraTeleport.getValue())
                Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketConfirmTeleport(((SPacketPlayerPosLook) event.getPacket()).getTeleportId() + 1));
        }
        if (removeFlags.getValue()) {
            ((SPacketPlayerPosLook) event.getPacket()).getFlags().remove(SPacketPlayerPosLook.EnumFlags.X_ROT);
            ((SPacketPlayerPosLook) event.getPacket()).getFlags().remove(SPacketPlayerPosLook.EnumFlags.Y_ROT);
        }
        if (setRotations.getValue()) {
            ((SPacketPlayerPosLook) event.getPacket()).pitch = mc.player.rotationPitch;
            ((SPacketPlayerPosLook) event.getPacket()).yaw = mc.player.rotationYaw;
        }
        switch (setPosMode.getValue()) {
            case "None":
                break;
            case "Push":
                ((SPacketPlayerPosLook) event.getPacket()).x = mc.player.posX;
                ((SPacketPlayerPosLook) event.getPacket()).y = mc.player.posY;
                ((SPacketPlayerPosLook) event.getPacket()).z = mc.player.posZ;
                break;
            case "Pull":
                mc.player.posX = ((SPacketPlayerPosLook) event.getPacket()).x;
                mc.player.posY = ((SPacketPlayerPosLook) event.getPacket()).y;
                mc.player.posZ = ((SPacketPlayerPosLook) event.getPacket()).z;
                break;
        }
    }

}
