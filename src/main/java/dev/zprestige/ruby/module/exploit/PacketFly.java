package dev.zprestige.ruby.module.exploit;

import dev.zprestige.ruby.events.MoveEvent;
import dev.zprestige.ruby.events.PacketEvent;
import dev.zprestige.ruby.module.Category;
import dev.zprestige.ruby.module.Module;
import dev.zprestige.ruby.module.ModuleInfo;
import dev.zprestige.ruby.setting.impl.BooleanSetting;
import dev.zprestige.ruby.setting.impl.FloatSetting;
import dev.zprestige.ruby.setting.impl.IntegerSetting;
import dev.zprestige.ruby.setting.impl.ModeSetting;
import dev.zprestige.ruby.util.EntityUtil;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.Arrays;
import java.util.Objects;
import java.util.function.Predicate;

@ModuleInfo(name = "PacketFly" , category = Category.Exploit, description = "Uses packets to fly like angel")
public class PacketFly extends Module {
    public ModeSetting type = createSetting("Type", "Packet", Arrays.asList("Packet", "Teleport", "Vanilla", "Factor"));
    public FloatSetting horizontalFactor = createSetting("Horizontal Factor", 1.0f, 0.1f, 10.0f);
    public FloatSetting upFactor = createSetting("Up Factor", 1.0f, 0.1f, 10.0f);
    public FloatSetting downFactor = createSetting("Down Factor", 1.0f, 0.1f, 10.0f);
    public BooleanSetting setBack = createSetting("Set Back", false);
    public IntegerSetting setBackValue = createSetting("Set Back Value", 5, 0, 10, (Predicate<Integer>) v -> setBack.getValue());
    public BooleanSetting noVelocity = createSetting("No Velocity", false);
    public BooleanSetting looped = createSetting("Looped", false);
    public IntegerSetting loops = createSetting("Loops", 1, 1, 10, (Predicate<Integer>) v -> looped.getValue());
    public BooleanSetting confirmTeleport = createSetting("Confirm Teleport", false);
    public BooleanSetting confirmExtraTeleport = createSetting("Confirm Extra Teleport", false, v -> confirmTeleport.getValue());
    public BooleanSetting removeFlags = createSetting("Remove Flags", false);
    public BooleanSetting setRotations = createSetting("Set Rotations", false);
    public ModeSetting setPosMode = createSetting("Set Pos Mode", "None", Arrays.asList("None", "Push", "Pull"));
    public BooleanSetting noClip = createSetting("No Clip", false);
    public BooleanSetting noCollisions = createSetting("No Collisions", false);
    public BooleanSetting spoofOnGround = createSetting("Spoof On Ground", false);
    public BooleanSetting useTimer = createSetting("Use Timer", false);
    public FloatSetting timerValue = createSetting("Timer Value", 1.0f, 0.1f, 2.0f);
    public int setBackTicks;

    @Override
    public void onTick() {
        mc.player.onGround = spoofOnGround.getValue();
        mc.player.noClip = !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(0.0, 0.0, 0.0)).isEmpty() && noClip.getValue();
        mc.player.collidedHorizontally = !noCollisions.getValue();
        mc.player.collidedVertically = !noCollisions.getValue();
        if (noVelocity.getValue())
            mc.player.setVelocity(0, 0, 0);
        if (setBack.getValue() && setBackTicks >= setBackValue.getValue()) {
            setBackTicks = 0;
            return;
        }
        mc.timer.tickLength = 50.0f / (useTimer.getValue() ? timerValue.getValue() : 1.0f);
        if (mc.gameSettings.keyBindJump.isKeyDown()) {
            if (looped.getValue()) {
                for (int i = 0; i < (looped.getValue() ? loops.getValue() : 1); i++) {
                    switch (type.getValue()) {
                        case "Factor":
                            mc.player.motionY = upFactor.getValue() / 100f;
                        case "Packet":
                            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + upFactor.getValue() / 100f, mc.player.posZ, false));
                            break;
                        case "Teleport":
                            mc.player.setPosition(mc.player.posX, mc.player.posY + upFactor.getValue() / 100f, mc.player.posZ);
                            break;
                        case "Vanilla":
                            mc.player.motionY = upFactor.getValue() / 100f;
                    }
                }
            }
        } else if (type.getValue().equals("Factor")) {
            mc.player.motionY = -downFactor.getValue() / 100f;
        }
        if (mc.gameSettings.keyBindSneak.isKeyDown()) {
            if (looped.getValue()) {
                for (int i = 0; i < (looped.getValue() ? loops.getValue() : 1); i++) {
                    switch (type.getValue()) {
                        case "Factor":
                            break;
                        case "Packet":
                            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - downFactor.getValue() / 100f, mc.player.posZ, false));
                            break;
                        case "Teleport":
                            mc.player.setPosition(mc.player.posX, mc.player.posY - downFactor.getValue() / 100f, mc.player.posZ);
                            break;
                        case "Vanilla":
                            mc.player.motionY = -downFactor.getValue() / 100f;
                    }
                }
            }
        }
        if (mc.gameSettings.keyBindForward.isKeyDown() || mc.gameSettings.keyBindLeft.isKeyDown() || mc.gameSettings.keyBindBack.isKeyDown() || mc.gameSettings.keyBindRight.isKeyDown()) {
            double[] motion = EntityUtil.getSpeed(horizontalFactor.getValue() / 100f);
                for (int i = 0; i < (looped.getValue() ? loops.getValue() : 1); i++) {
                    switch (type.getValue()) {
                        case "Factor":
                            break;
                        case "Packet":
                            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayer.Position(mc.player.posX + motion[0], mc.player.posY, mc.player.posZ + motion[1], false));
                            break;
                        case "Teleport":
                            mc.player.setPosition(mc.player.posX + motion[0], mc.player.posY, mc.player.posZ + motion[1]);
                            break;
                        case "Vanilla":
                            mc.player.motionX = motion[0];
                            mc.player.motionZ = motion[1];
                    }
                }
            }
        if (setBack.getValue() && setBackTicks < setBackValue.getValue())
            setBackTicks++;
    }


    @SubscribeEvent
    public void onMove(MoveEvent event) {
        if (nullCheck() || !isEnabled())
            return;
        double[] motion = EntityUtil.getSpeed(horizontalFactor.getValue() / 100f);
        if (type.getValue().equals("Factor")) {
            event.motionX = motion[0];
            event.motionZ = motion[1];
        } else
            event.setCanceled(true);
    }

    @SubscribeEvent
    public void onPacketReceive(PacketEvent.PacketReceiveEvent event) {
        if (nullCheck() || !isEnabled() || !(event.getPacket() instanceof SPacketPlayerPosLook))
            return;
        if (confirmTeleport.getValue()) {
            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketConfirmTeleport(((SPacketPlayerPosLook) event.getPacket()).getTeleportId()));
            if (confirmExtraTeleport.getValue())
                Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketConfirmTeleport(((SPacketPlayerPosLook) event.getPacket()).getTeleportId() + 1));
        }
        if (removeFlags.getValue()) {
            ((SPacketPlayerPosLook) event.getPacket()).getFlags().remove(SPacketPlayerPosLook.EnumFlags.X_ROT);
            ((SPacketPlayerPosLook) event.getPacket()).getFlags().remove(SPacketPlayerPosLook.EnumFlags.Y_ROT);
        }
        if (setRotations.getValue()) {
            ((SPacketPlayerPosLook) event.getPacket()).pitch = mc.player.rotationPitch;
            ((SPacketPlayerPosLook) event.getPacket()).yaw = mc.player.rotationYaw;
        }
        switch (setPosMode.getValue()) {
            case "None":
                break;
            case "Push":
                ((SPacketPlayerPosLook) event.getPacket()).x = mc.player.posX;
                ((SPacketPlayerPosLook) event.getPacket()).y = mc.player.posY;
                ((SPacketPlayerPosLook) event.getPacket()).z = mc.player.posZ;
                break;
            case "Pull":
                mc.player.posX = ((SPacketPlayerPosLook) event.getPacket()).x;
                mc.player.posY = ((SPacketPlayerPosLook) event.getPacket()).y;
                mc.player.posZ = ((SPacketPlayerPosLook) event.getPacket()).z;
                break;
        }
    }

}
